目前是理解成一個陣列，先把root()、addChild(p,n)、cut(t)、paste(n,t)，這些函數定義好

再來，先設定一組以知大小的陣列，舉例:[x,5,7,t,6,y,b....n-1]，將陣列第一個位置定義成parent，當執行root()的函數時，將值傳給陣列第一個

然後再設定陣列裡面除第一個以後的位置定義成children，當執行addChild時，將輸入的n放入要插入的節點後面

再來是cut，當執行cut將第t個點開始到n-1中間這段的截出，成為一個新的樹(陣列)，並將第t個點定義為parent

最後，paste，將剛剛截出來的樹(陣列)加到樹(陣列)的n後面，然後將t定義成children。

(以上為上次樹的作業)

套用以上的樹來做的話
個人理解是以下

首先以隻大小的陣列[x,5,7,t,6,y,b....n-1]，先更改為題目所需的{0, 1, 2, 3, 4, 5, 6, 7} 
由於合格樹，的要求在誤差(深度)為1 or -1 的情況下
如果是完美樹的話，則不能有誤差

因此需設立一個條件式，讓樹可以在每次有數字進到樹裡時，自動排序，讓樹能夠保持完美。(但是我不知道該怎麼說，所以我會一個步驟一個步驟打出來)

1.先加入1這個數字
  則樹 = 1(右)
  (還是合格樹)左右差0
  
2.再加入一個數2
  則樹 = 1-2(右)
            (左)
  (依舊算是合格樹)右邊差1

3.再來是重點，當加禁第3個數3時
  則樹 = 1-2-3(右)
  這樣誤差就大於1了，目前誤差是2
  電腦就要依照我們給他的條件式來自動排序，讓樹可以保持完美或合格
  由於第1個數必須要滿足同時大於左邊的數，小於右邊的數這個法則
  所以會是以以下的方法來排序 =>
                            原本:
                                                 3
                                               /
                                             2
                                      (右)  /
                               (中(第一個))1
                                      (左)
                             
                            排序方法:將2做為第一個，把1退到下面，像下面這樣
                            
                                    (右)  3
                                        / 
                                   (中)2
                                        \
                                    (左)  1
                                    
                                    因為左右各差1，因此可以抵銷，即可達到完美樹
                                    
 4.當加進4時
                                            4
                                           /
                                    (右)  3
                                        / 
                                   (中)2
                                        \
                                    (左)  1
                                    
                                    此時，再2的角度來看，它的右邊有3跟4，左邊則是只有1
                                    深度2扣掉1，誤差值為1，可以接受，還是合格的樹
                                    
 5.再加進5
                                              5
                                             /
                                            4
                                           /
                                    (右)  3
                                        / 
                                   (中)2
                                        \
                                    (左)  1
                                    
                                    這時候就不行了右邊的深度為3，無法與左邊抵銷(左邊只有1一個數)，
                                    因此要電腦就要再次進行排序以達到合格或是完美。
                             
                              排序方法:從3著手，將4往上推，3則推到4的左邊像下圖
                                            5
                                           /
                                    (右)  4
                                        /  \
                                   (中)2     3
                                        \
                                    (左)  1                          
                                    
                                    這樣左右的深度差就等於1，在可以接受的範圍，合格!!
                                    
                                    目前我是理解到這邊，但要我用程式碼些出來我還真不知道該怎麼寫，萬分抱歉!!
                                    
                                     
                                      
                                      
                                      
